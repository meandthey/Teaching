plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
par(oldpar)
#############################
## ===== 스타일 =====
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(0.5,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
par(oldpar)
#############################
#############################
## ===== 스타일 =====
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(1,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
par(oldpar)
#############################
#############################
## ===== 스타일 =====
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(1.3,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="전형적인 기업의 비용곡선",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
par(oldpar)
#############################
## ===== 스타일 =====
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(1.3,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="전형적인 기업의 비용곡선",
cex.lab=1.8, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
par(oldpar)
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(1.8,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="전형적인 기업의 비용곡선",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
par(oldpar)
oldpar <- par(no.readonly = TRUE)
##### 그래프 바깥쪽 여백(margin) 조정정
graph_margin_opt <- c(
7, # 아래쪽 여백
7, # 왼쪽 여백
2, # 위쪽 여백
1  # 오른쪽 여백
)
graph_mgp_opt <- c(
5,  # 축제목(xlab, lab)이 축선에서 떨어져 있는 정도
1,  # 눈금 숫자가 축선에서 떨어져 있는 정도
0   # 축선 자체 위치
)
##### 그래프 선을 여유있게 그릴건지?
graph_xaxs_opt <- "i"   # i: 딱 정확히, r: 여유있게
graph_yaxs_opt <- "i"   # i: 딱 정확히, r: 여유있게
##### 축의 눈금(tick)을 표시할건지?
graph_xaxt_opt <- "n"   # n: tick 안그림,  s: tick 그림
graph_yaxt_opt <- "n"   # n: tick 안그림,  s: tick 그림
par(mar = graph_margin_opt, mgp = graph_mgp_opt,
xaxs = graph_xaxs_opt, yaxs = graph_yaxs_opt)
q   <- 1:10
AFC <- c(3.00, 1.50, 1.00, 0.75, 0.60, 0.50, 0.43, 0.38, 0.33, 0.30)
AVC <- c(0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 1.10, 1.20)
ATC <- c(3.30, 1.90, 1.50, 1.35, 1.30, 1.30, 1.33, 1.38, 1.43, 1.50)
MC  <- c(0.30, 0.50, 0.70, 0.90, 1.10, 1.30, 1.50, 1.70, 1.90, 2.10)
mat <- cbind(AFC, AVC, ATC, MC)
mat
q
#############################
## ===== 공통 설정 =====
oldpar <- par(no.readonly = TRUE)
##### 그래프 바깥쪽 여백(margin) 조정정
graph_margin_opt <- c(
7, # 아래쪽 여백
7, # 왼쪽 여백
2, # 위쪽 여백
1  # 오른쪽 여백
)
graph_mgp_opt <- c(
5,  # 축제목(xlab, lab)이 축선에서 떨어져 있는 정도
1,  # 눈금 숫자가 축선에서 떨어져 있는 정도
0   # 축선 자체 위치
)
##### 그래프 선을 여유있게 그릴건지?
graph_xaxs_opt <- "i"   # i: 딱 정확히, r: 여유있게
graph_yaxs_opt <- "i"   # i: 딱 정확히, r: 여유있게
##### 축의 눈금(tick)을 표시할건지?
graph_xaxt_opt <- "n"   # n: tick 안그림,  s: tick 그림
graph_yaxt_opt <- "n"   # n: tick 안그림,  s: tick 그림
par(mar = graph_margin_opt, mgp = graph_mgp_opt,
xaxs = graph_xaxs_opt, yaxs = graph_yaxs_opt)
q   <- 1:10
AFC <- c(3.00, 1.50, 1.00, 0.75, 0.60, 0.50, 0.43, 0.38, 0.33, 0.30)
AVC <- c(0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 1.10, 1.20)
ATC <- c(3.30, 1.90, 1.50, 1.35, 1.30, 1.30, 1.33, 1.38, 1.43, 1.50)
MC  <- c(0.30, 0.50, 0.70, 0.90, 1.10, 1.30, 1.50, 1.70, 1.90, 2.10)
mat <- cbind(AFC, AVC, ATC, MC)
xlim_all <- c(0, 10)         # ← x축 0부터
ylim_all <- c(0, 3.5)        # ← y축 0부터
matplot(q, mat, type = "o", pch = 16, lty = 1,
xlab = "산출량", ylab = "비용",
xaxt = "n", yaxt = "n",
xlim = xlim_all, ylim = ylim_all,     # ← 범위에 (0,0) 포함
cex.lab = 2, cex.axis = 2, cex.main = 2)
## (선택) 0에서 시작하는 격자 (배경)
abline(h = seq(0, 3.5, by = 0.25), col = "gray85", lty = "dotted")
abline(v = seq(0, 10,  by = 1),    col = "gray85", lty = "dotted")
## 원점에 축 그리기 (pos=0)
axis(1, at = 0:10, pos = 0, cex.axis = 2)                     # x축을 y=0에
axis(2, at = seq(0, 3.50, 0.25), pos = 0, las = 1, cex.axis = 2)  # y축을 x=0에
## 범례/라벨/점 등은 그대로
legend("topright", legend = c("AFC","AVC","ATC","MC"),
col = 1:4, pch = 20, lty = 1, bty = "n")
text(9, 2.2, "MC", col = 4, cex = 1.5)
text(9, 1.5, "ATC", col = 3, cex = 1.5)
text(9, 1.2, "AVC", col = 2, cex = 1.5)
text(9, 0.4, "AFC", col = 1, cex = 1.5)
#############################
#############################
## ===== 스타일 =====
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(1.8,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="전형적인 기업의 비용곡선",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
par(oldpar)
text(13, 0.3, "AFC", col = 4, cex = 1.5)
#############################
##### 338 page 13.5
#############################
#############################
## ===== 스타일 =====
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(1.8,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="전형적인 기업의 비용곡선",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
par(oldpar)
text(13, 0.3, "AFC", col = 4, cex = 1.5)
text(13, 0.3, "AFC", col = 4, cex = 1.5)
#############################
##### 338 page 13.5
#############################
#############################
## ===== 스타일 =====
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(1.8,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="전형적인 기업의 비용곡선",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
text(13, 0.3, "AFC", col="#3569d6", cex = 1.5)
text(13, 0.6, "AVC", col = "#2f5db9", cex = 1.5)
text(13, 0.7, "AVC", col = "#2f5db9", cex = 1.5)
text(13, 1.3, "ATC", col = "#244a93", cex = 1.5)
text(13, 1.1, "ATC", col = "#244a93", cex = 1.5)
text(13, 1.15, "ATC", col = "#244a93", cex = 1.5)
text(13, 2.2, "MC", col = "#c83c2b", cex = 1.5)
#############################
##### 338 page 13.5
#############################
#############################
## ===== 스타일 =====
oldpar <- par(no.readonly = TRUE)
par(mar=c(4,5,2,1), mgp=c(3,1,0), xaxs="i", yaxs="i")
## ===== 범위 =====
xlim_all <- c(0, 14)
ylim_all <- c(0, 3.2)
q <- seq(1.8,  xlim_all[2], length.out = 1200)
## ===== 비용함수: AFC, AVC, ATC =====
F  <- 3.0
afc_fun <- function(q) F/q
a  <- 0.45; b <- 0.005; c <- 0.50; qv <- 5
avc_fun <- function(q) a + b*(q - qv)^2 + c/q
atc_fun <- function(q) afc_fun(q) + avc_fun(q)
## ATC 최소점 (이론상 여기서 MC = ATC)
opt <- optimize(atc_fun, interval = c(1, 13))
q_atc_min <- opt$minimum
atc_min   <- opt$objective
## ===== MC: 더 깊은 U자 =====
## MC(q) = m0 + alpha*(q - q_m) + beta*(q - q_m)^2
q_m      <- 4.2        # MC의 꼭지점 위치(좌우 이동)
MC_at_1  <- 0.70       # y절편 수준 유지
beta     <- 0.035      # ▶ 곡률(깊이). 이전(예: 0.03)보다 크게 → 더 깊은 U
A1 <- (1 - q_m)
A2 <- (q_atc_min - q_m)
alpha <- ( MC_at_1 - atc_min - beta*(A1^2 - A2^2) ) / (A1 - A2)
m0    <- MC_at_1 - alpha*A1 - beta*A1^2
mc_fun <- function(q) m0 + alpha*(q - q_m) + beta*(q - q_m)^2
## ===== 그리기 =====
plot(NA, xlim=xlim_all, ylim=ylim_all,
xlab="산출량", ylab="비용", main="전형적인 기업의 비용곡선",
cex.lab=1.4, cex.axis=1.2)
# axis(1, at=seq(0,14,2))
# axis(2, at=seq(0,3.2,0.25), las=1)
#grid(col="grey85", lty="dotted")
lines(q, afc_fun(q), lwd=3, col="#3569d6")      # AFC
lines(q, avc_fun(q), lwd=3, col="#2f5db9")      # AVC
lines(q, atc_fun(q), lwd=3, col="#244a93")      # ATC
lines(q, mc_fun(q),  lwd=3, col="#c83c2b")      # MC (더 깊은 U자)
## 체크 포인트
segments(q_atc_min, 0, q_atc_min, atc_min, lty=3, col="gray55", lwd=2)
points(q_atc_min, atc_min, pch=19, cex=1.1, col="#c83c2b")  # MC=ATC at min
#points(1, mc_fun(1), pch=21, bg="white", cex=1.0)           # MC(1)=0.7
text(13, 0.3, "AFC", col="#3569d6", cex = 1.5)
text(13, 0.7, "AVC", col = "#2f5db9", cex = 1.5)
text(13, 1.15, "ATC", col = "#244a93", cex = 1.5)
text(13, 2.2, "MC", col = "#c83c2b", cex = 1.5)
par(oldpar)
