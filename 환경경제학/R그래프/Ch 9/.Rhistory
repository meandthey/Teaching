)
graph_mgp_opt <- c(
3,  # 축제목(xlab, lab)이 축선에서 떨어져 있는 정도
1,  # 눈금 숫자가 축선에서 떨어져 있는 정도
0   # 축선 자체 위치
)
##### 그래프 선을 여유있게 그릴건지?
graph_xaxs_opt <- "i"   # i: 딱 정확히, r: 여유있게
graph_yaxs_opt <- "i"   # i: 딱 정확히, r: 여유있게
##### 축의 눈금(tick)을 표시할건지?
graph_xaxt_opt <- "n"   # n: tick 안그림,  s: tick 그림
graph_yaxt_opt <- "n"   # n: tick 안그림,  s: tick 그림
par(mar = graph_margin_opt, mgp = graph_mgp_opt,
xaxs = graph_xaxs_opt, yaxs = graph_yaxs_opt, xaxt= graph_xaxt_opt, yaxt= graph_yaxt_opt)
## x, y 범위
xlim_all <- c(0,65)
ylim_all <- c(0,65)
x <- seq(xlim_all[1], xlim_all[2], length.out = 1000)
## 함수 정의 (function 형태로 정의해야 교차점 자동 계산 가능)
## 공급곡선: 우상향
demand_fun_a  <- function(z) 60 - 1*z
demand_fun_b  <- function(z) 40 - 1*z
supply_fun <- function(z) 0 + 0.75*z
## 교차점 계산
#diff1 <- function(z) supply_fun(z)  - demand_fun(z)
#q_star  <- uniroot(diff1, xlim_all)$root
#y_star  <- supply_fun(q_star)
## 빈 캔버스
graph_cex.axis_opt <- 2.0 # 눈금(tick)의 숫자 크기 조절
graph_cex.lab_opt <- 2.0  # 축제목의 크기 조절
graph_cex.main_opt <- 2.0 # 그래프 제목의 글자 크기 조절절
plot(NA, xlim = xlim_all, ylim = ylim_all,
xlab = "배출량", ylab = "금액",
main = "몬테로 메커니즘",
cex.axis = graph_cex.axis_opt,
cex.lab = graph_cex.lab_opt,
cex.main = graph_cex.main_opt)
# 곡선
lines(x, demand_fun_a(x),  lwd = 2, col = "blue")
lines(x, demand_fun_b(x), lwd = 2, col = "blue")
lines(x, supply_fun(x), lwd = 2, col = "blue")
## 교차점 계산
diff1 <- function(z) demand_fun_a(z) - supply_fun(z)
diff2 <- function(z) demand_fun_b(z) - supply_fun(z)
root_pos1 <- uniroot(diff1, c(0, 100))$root
root_pos2 <- uniroot(diff2, c(0, 100))$root
abline(h = supply_fun(root_pos1) ,  lty = 2, col = "gray60", lwd = 0.1)
abline(h = supply_fun(root_pos2) ,  lty = 2, col = "gray60", lwd = 0.1)
abline(v = (root_pos1) ,  lty = 2, col = "gray60", lwd = 0.1)
abline(v = (root_pos2) ,  lty = 2, col = "gray60", lwd = 0.1)
mtext(expression(e[0]),
side = 1,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = uniroot(demand_fun_a, c(0, 100))$root,      # 텍스트 좌표 위치
line = 1.2,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
mtext(expression(e[A]),
side = 1,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = root_pos1,      # 텍스트 좌표 위치
line = 1,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
mtext(expression(e[1]),
side = 1,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = root_pos2,      # 텍스트 좌표 위치
line = 1,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
mtext(expression(P[1]),
side = 2,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = supply_fun(root_pos2),      # 텍스트 좌표 위치
line = 1.2,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
mtext(expression(P[A]),
side = 2,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = supply_fun(root_pos1),      # 텍스트 좌표 위치
line = 1.2,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
# ----- 파라미터 -----
q_star <- 0                 # 중앙 q*
gap    <- 1.2               # 두 곡선 평균이 q*에서 떨어진 거리
mu_L   <- q_star - gap      # 저감행위 할 경우 평균(왼쪽)
mu_R   <- q_star + gap      # 저감행위 안 할 경우 평균(오른쪽)
sigma  <- 0.6               # 표준편차(두 곡선 동일 가정)
# x 범위
x <- seq(q_star - 4*gap, q_star + 4*gap, length.out = 1000)
# 데이터 생성
df <- tibble(
x = x,
pdf_L = dnorm(x, mean = mu_L, sd = sigma),  # 저감행위를 할 경우의 오염도 발생 확률
pdf_R = dnorm(x, mean = mu_R, sd = sigma)   # 저감행위를 안 할 경우의 오염도 발생 확률
)
library(ggplot2)
library(dplyr)
# ----- 파라미터 -----
q_star <- 0                 # 중앙 q*
gap    <- 1.2               # 두 곡선 평균이 q*에서 떨어진 거리
mu_L   <- q_star - gap      # 저감행위 할 경우 평균(왼쪽)
mu_R   <- q_star + gap      # 저감행위 안 할 경우 평균(오른쪽)
sigma  <- 0.6               # 표준편차(두 곡선 동일 가정)
# x 범위
x <- seq(q_star - 4*gap, q_star + 4*gap, length.out = 1000)
# 데이터 생성
df <- tibble(
x = x,
pdf_L = dnorm(x, mean = mu_L, sd = sigma),  # 저감행위를 할 경우의 오염도 발생 확률
pdf_R = dnorm(x, mean = mu_R, sd = sigma)   # 저감행위를 안 할 경우의 오염도 발생 확률
)
# 긴 형식으로 변환
df_long <- df %>%
tidyr::pivot_longer(cols = c(pdf_L, pdf_R),
names_to = "case", values_to = "pdf") %>%
mutate(case = ifelse(case == "pdf_L",
"저감행위를 할 경우의 오염도 발생 확률",
"저감행위를 안 할 경우의 오염도 발생 확률"))
# 그림
p <- ggplot(df_long, aes(x = x, y = pdf, group = case)) +
geom_line(linewidth = 1) +
geom_vline(xintercept = q_star, linewidth = 0.8) +                       # q*
geom_vline(xintercept = c(mu_L, mu_R), linetype = "dashed", linewidth = 0.6) +  # 두 평균
scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
labs(x = "오염도", y = "확률") +
theme_minimal(base_size = 13) +
theme(
panel.grid.minor = element_blank(),
legend.position = "none",
plot.margin = margin(10, 10, 10, 10)
)
# 상단 레이블(원본처럼 곡선 위에 텍스트)
p +
annotate("text", x = mu_L, y = max(df$pdf_L)*1.05,
label = "저감행위를 할 경우의\n오염도 발생 확률", hjust = 0.5, vjust = 0) +
annotate("text", x = mu_R, y = max(df$pdf_R)*1.05,
label = "저감행위를 안 할 경우의\n오염도 발생 확률", hjust = 0.5, vjust = 0) +
annotate("text", x = q_star, y = 0, label = expression(q^"*"),
vjust = 1.6, size = 5)
#####
library(ggplot2)
library(dplyr)
library(tidyr)
# ----- 파라미터 -----
q_star <- 0                 # 중앙 q*
gap    <- 1.2               # 두 분포의 중심 간 거리
mu_L   <- q_star - gap      # 저감행위 할 경우 평균
mu_R   <- q_star + gap      # 저감행위 안 할 경우 평균
sigma  <- 0.6               # 표준편차
# ----- 데이터 생성 -----
x <- seq(q_star - 4*gap, q_star + 4*gap, length.out = 1000)
df <- tibble(
x = x,
pdf_L = dnorm(x, mean = mu_L, sd = sigma),
pdf_R = dnorm(x, mean = mu_R, sd = sigma)
)
df_long <- df %>%
pivot_longer(cols = c(pdf_L, pdf_R),
names_to = "case", values_to = "pdf") %>%
mutate(case = ifelse(case == "pdf_L",
"저감행위를 할 경우의 오염도 발생 확률",
"저감행위를 안 할 경우의 오염도 발생 확률"))
# ----- 그래프 -----
p <- ggplot(df_long, aes(x = x, y = pdf, color = case)) +
geom_line(linewidth = 1) +
geom_vline(xintercept = q_star, linewidth = 0.8, color = "black") +  # q*
geom_vline(xintercept = c(mu_L, mu_R), linetype = "dashed", color = "gray50") +
scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
scale_color_manual(values = c("#1B4F72", "#922B21")) +
labs(x = "오염도", y = "확률") +
theme_minimal(base_size = 13) +
theme(
legend.position = "none",
panel.grid.minor = element_blank(),
plot.margin = margin(10, 10, 10, 10)
)
# ----- 상단 및 q* 표시 -----
p +
annotate("text", x = mu_L, y = max(df$pdf_L)*1.05,
label = "저감행위를 할 경우의\n오염도 발생 확률", hjust = 0.5, vjust = 0, size = 4.2) +
annotate("text", x = mu_R, y = max(df$pdf_R)*1.05,
label = "저감행위를 안 할 경우의\n오염도 발생 확률", hjust = 0.5, vjust = 0, size = 4.2) +
annotate("text", x = q_star, y = 0, label = expression(q^"*"),
vjust = 1.8, hjust = 0.5, size = 5)
#####
library(ggplot2)
library(dplyr)
library(tidyr)
# ----- 파라미터 -----
q_star <- 0                 # 중앙 q*
gap    <- 1.2               # 두 분포의 중심 간 거리
mu_L   <- q_star - gap      # 저감행위 할 경우 평균
mu_R   <- q_star + gap      # 저감행위 안 할 경우 평균
sigma  <- 0.6               # 표준편차
# ----- 데이터 생성 -----
x <- seq(q_star - 4*gap, q_star + 4*gap, length.out = 1000)
df <- tibble(
x = x,
pdf_L = dnorm(x, mean = mu_L, sd = sigma),
pdf_R = dnorm(x, mean = mu_R, sd = sigma)
)
df_long <- df %>%
pivot_longer(cols = c(pdf_L, pdf_R),
names_to = "case", values_to = "pdf") %>%
mutate(case = ifelse(case == "pdf_L",
"저감행위를 할 경우의 오염도 발생 확률",
"저감행위를 안 할 경우의 오염도 발생 확률"))
# ----- 그래프 -----
p <- ggplot(df_long, aes(x = x, y = pdf, color = case)) +
geom_line(linewidth = 1) +
geom_vline(xintercept = q_star, linewidth = 0.8, color = "black") +  # q*
geom_vline(xintercept = c(mu_L, mu_R), linetype = "dashed", color = "gray50") +
scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
scale_color_manual(values = c("#1B4F72", "#922B21")) +
labs(x = "오염도", y = "확률") +
theme_minimal(base_size = 13) +
theme(
legend.position = "none",
panel.grid.minor = element_blank(),
plot.margin = margin(10, 10, 10, 10)
)
# ----- 상단 및 q* 표시 -----
p +
annotate("text", x = mu_L, y = max(df$pdf_L)*1.05,
label = "저감행위를 할 경우의\n오염도 발생 확률", hjust = 0.5, vjust = 0, size = 4.2) +
annotate("text", x = mu_R, y = max(df$pdf_R)*1.05,
label = "저감행위를 안 할 경우의\n오염도 발생 확률", hjust = 0.5, vjust = 0, size = 4.2) +
annotate("text", x = q_star, y = 0, label = expression(q^"*"),
vjust = 1.8, hjust = 0.5, size = 5)
# ----- 상단 및 q* 표시 -----
p +
annotate(
"text",
x = q_star, y = 0,
label = 'q^"*"',   # 문자열로 전달
parse = TRUE,      # 수식으로 파싱
vjust = 1.8, hjust = 0.5, size = 5
)
## ===== 공통 설정 =====
oldpar <- par(no.readonly = TRUE)
##### 그래프 바깥쪽 여백(margin) 조정정
graph_margin_opt <- c(
5, # 아래쪽 여백
5, # 왼쪽 여백
3, # 위쪽 여백
3  # 오른쪽 여백
)
graph_mgp_opt <- c(
3,  # 축제목(xlab, lab)이 축선에서 떨어져 있는 정도
1,  # 눈금 숫자가 축선에서 떨어져 있는 정도
0   # 축선 자체 위치
)
##### 그래프 선을 여유있게 그릴건지?
graph_xaxs_opt <- "i"   # i: 딱 정확히, r: 여유있게
graph_yaxs_opt <- "i"   # i: 딱 정확히, r: 여유있게
##### 축의 눈금(tick)을 표시할건지?
graph_xaxt_opt <- "n"   # n: tick 안그림,  s: tick 그림
graph_yaxt_opt <- "n"   # n: tick 안그림,  s: tick 그림
par(mar = graph_margin_opt, mgp = graph_mgp_opt,
xaxs = graph_xaxs_opt, yaxs = graph_yaxs_opt, xaxt= graph_xaxt_opt, yaxt= graph_yaxt_opt)
## x, y 범위
xlim_all <- c(0,65)
ylim_all <- c(0,65)
x <- seq(xlim_all[1], xlim_all[2], length.out = 1000)
## 함수 정의 (function 형태로 정의해야 교차점 자동 계산 가능)
## 공급곡선: 우상향
demand_fun_a  <- function(z) 60 - 1*z
demand_fun_b  <- function(z) 40 - 1*z
supply_fun <- function(z) 0 + 0.75*z
## 교차점 계산
#diff1 <- function(z) supply_fun(z)  - demand_fun(z)
#q_star  <- uniroot(diff1, xlim_all)$root
#y_star  <- supply_fun(q_star)
## 빈 캔버스
graph_cex.axis_opt <- 2.0 # 눈금(tick)의 숫자 크기 조절
graph_cex.lab_opt <- 2.0  # 축제목의 크기 조절
graph_cex.main_opt <- 2.0 # 그래프 제목의 글자 크기 조절절
plot(NA, xlim = xlim_all, ylim = ylim_all,
xlab = "배출량", ylab = "금액",
main = "몬테로 메커니즘",
cex.axis = graph_cex.axis_opt,
cex.lab = graph_cex.lab_opt,
cex.main = graph_cex.main_opt)
# 곡선
lines(x, demand_fun_a(x),  lwd = 2, col = "blue")
lines(x, demand_fun_b(x), lwd = 2, col = "blue")
lines(x, supply_fun(x), lwd = 2, col = "blue")
## 교차점 계산
diff1 <- function(z) demand_fun_a(z) - supply_fun(z)
diff2 <- function(z) demand_fun_b(z) - supply_fun(z)
root_pos1 <- uniroot(diff1, c(0, 100))$root
root_pos2 <- uniroot(diff2, c(0, 100))$root
abline(h = supply_fun(root_pos1) ,  lty = 2, col = "gray60", lwd = 0.1)
abline(h = supply_fun(root_pos2) ,  lty = 2, col = "gray60", lwd = 0.1)
abline(v = (root_pos1) ,  lty = 2, col = "gray60", lwd = 0.1)
abline(v = (root_pos2) ,  lty = 2, col = "gray60", lwd = 0.1)
mtext(expression(e[0]),
side = 1,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = uniroot(demand_fun_b, c(0, 100))$root,      # 텍스트 좌표 위치
line = 1.2,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
mtext(expression(e[1]),
side = 1,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = root_pos1,      # 텍스트 좌표 위치
line = 1,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
mtext(expression(e[A]),
side = 1,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = root_pos2,      # 텍스트 좌표 위치
line = 1,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
mtext(expression(P[A]),
side = 2,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = supply_fun(root_pos2),      # 텍스트 좌표 위치
line = 1.2,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
mtext(expression(P[1]),
side = 2,     # 1:x축, 2:y축, 3:위쪽, 4:오른쪽
at = supply_fun(root_pos1),      # 텍스트 좌표 위치
line = 1.2,   # 축에서 가까운 정도 (숫자가 커지면 축선에서 멀어짐)
cex = 2,      # 글자 크기
las = 1       # 0: 축과평행,  1:수평으로 (똑바르게),  2:축과 수직,  3:항상 수직
)
#####
library(ggplot2)
library(dplyr)
library(tidyr)
# ----- 파라미터 -----
q_star <- 0                 # 중앙 q*
gap    <- 1.2               # 두 분포의 중심 간 거리
mu_L   <- q_star - gap      # 저감행위 할 경우 평균
mu_R   <- q_star + gap      # 저감행위 안 할 경우 평균
sigma  <- 0.6               # 표준편차
# ----- 데이터 생성 -----
x <- seq(q_star - 4*gap, q_star + 4*gap, length.out = 1000)
df <- tibble(
x = x,
pdf_L = dnorm(x, mean = mu_L, sd = sigma),
pdf_R = dnorm(x, mean = mu_R, sd = sigma)
)
df_long <- df %>%
pivot_longer(cols = c(pdf_L, pdf_R),
names_to = "case", values_to = "pdf") %>%
mutate(case = ifelse(case == "pdf_L",
"저감행위를 할 경우의 오염도 발생 확률",
"저감행위를 안 할 경우의 오염도 발생 확률"))
# ----- 그래프 -----
p <- ggplot(df_long, aes(x = x, y = pdf, color = case)) +
geom_line(linewidth = 1) +
geom_vline(xintercept = q_star, linewidth = 0.8, color = "black") +  # q*
geom_vline(xintercept = c(mu_L, mu_R), linetype = "dashed", color = "gray50") +
scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
scale_color_manual(values = c("#1B4F72", "#922B21")) +
labs(x = "오염도", y = "확률") +
theme_minimal(base_size = 13) +
theme(
legend.position = "none",
panel.grid.minor = element_blank(),
plot.margin = margin(10, 10, 10, 10)
)
# ----- 상단 및 q* 표시 -----
p +
annotate(
"text",
x = q_star, y = 0,
label = 'q^"*"',   # 문자열로 전달
parse = TRUE,      # 수식으로 파싱
vjust = 1.8, hjust = 0.5, size = 5
)
#####
library(ggplot2)
library(dplyr)
library(tidyr)
# ----- 파라미터 -----
q_star <- 0                 # 중앙 q*
gap    <- 1.2               # 두 분포의 중심 간 거리
mu_L   <- q_star - gap      # 저감행위 할 경우 평균
mu_R   <- q_star + gap      # 저감행위 안 할 경우 평균
sigma  <- 0.6               # 표준편차
# ----- 데이터 생성 -----
x <- seq(q_star - 4*gap, q_star + 4*gap, length.out = 1000)
df <- tibble(
x = x,
pdf_L = dnorm(x, mean = mu_L, sd = sigma),
pdf_R = dnorm(x, mean = mu_R, sd = sigma)
)
df_long <- df %>%
pivot_longer(cols = c(pdf_L, pdf_R),
names_to = "case", values_to = "pdf") %>%
mutate(case = ifelse(case == "pdf_L",
"저감행위를 할 경우의 오염도 발생 확률",
"저감행위를 안 할 경우의 오염도 발생 확률"))
# ----- 그래프 -----
p <- ggplot(df_long, aes(x = x, y = pdf, color = case)) +
geom_line(linewidth = 1) +
geom_vline(xintercept = q_star, linewidth = 0.8, color = "black") +  # q*
geom_vline(xintercept = c(mu_L, mu_R), linetype = "dashed", color = "gray50") +
scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
scale_color_manual(values = c("#1B4F72", "#922B21")) +
labs(x = "오염도", y = "확률") +
theme_minimal(base_size = 13) +
theme(
legend.position = "none",
panel.grid.minor = element_blank(),
plot.margin = margin(10, 10, 10, 10)
)
# ----- 상단 및 q* 표시 -----
p +
annotate(
"text",
x = q_star, y = 0,
label = 'q^"*"',   # 문자열로 전달
parse = TRUE,      # 수식으로 파싱
vjust = 1.8, hjust = 0.5, size = 5
)
library(ggplot2)
library(dplyr)
library(tidyr)
# ----- 파라미터 -----
q_star <- 0                 # 중앙 q*
gap    <- 1.2               # 두 분포의 중심 간 거리
mu_L   <- q_star - gap      # 저감행위 할 경우 평균
mu_R   <- q_star + gap      # 저감행위 안 할 경우 평균
sigma  <- 0.6               # 표준편차
# ----- 데이터 생성 -----
x <- seq(q_star - 4*gap, q_star + 4*gap, length.out = 1000)
df <- tibble(
x = x,
pdf_L = dnorm(x, mean = mu_L, sd = sigma),
pdf_R = dnorm(x, mean = mu_R, sd = sigma)
)
df_long <- df %>%
pivot_longer(cols = c(pdf_L, pdf_R),
names_to = "case", values_to = "pdf") %>%
mutate(case = ifelse(case == "pdf_L",
"저감행위를 할 경우의 오염도 발생 확률",
"저감행위를 안 할 경우의 오염도 발생 확률"))
# ----- 그래프 -----
p <- ggplot(df_long, aes(x = x, y = pdf, color = case)) +
geom_line(linewidth = 1) +
geom_vline(xintercept = q_star, linewidth = 0.8, color = "black") +  # q*
geom_vline(xintercept = c(mu_L, mu_R), linetype = "dashed", color = "gray50") +
scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
scale_color_manual(values = c("#1B4F72", "#922B21")) +
labs(x = "", y = "확률") +
theme_minimal(base_size = 13) +
theme(
legend.position = "none",
panel.grid.minor = element_blank(),
plot.margin = margin(10, 10, 10, 10)
)
# ----- 상단 및 q* 표시 -----
p +
annotate(
"text",
x = q_star, y = 0,
label = 'q^"*"',   # 문자열로 전달
parse = TRUE,      # 수식으로 파싱
vjust = 1.8, hjust = 0.5, size = 5
)
# ----- 상단 및 q* 표시 -----
p +
geom_text(
data = data.frame(x = q_star, y = 0, lab = 'q^"*"' ),
aes(x, y, label = lab),
parse = TRUE,
vjust = 1.8, hjust = 0.5, size = 5
)
# ----- 상단 및 q* 표시 -----
p +
# ----- 상단 및 q* 표시 -----
p +
annotate("text", x = mu_L, y = max(df$pdf_L)*1.05,
label = "저감행위를 할 경우의\n오염도 발생 확률",
hjust = 0.5, vjust = 0, size = 4.2) +
annotate("text", x = mu_R, y = max(df$pdf_R)*1.05,
label = "저감행위를 안 할 경우의\n오염도 발생 확률",
hjust = 0.5, vjust = 0, size = 4.2) +
annotate("text", x = q_star, y = 0,
label = 'q^"*"',   # 문자열 형태로 입력
parse = TRUE,      # 수식으로 해석
vjust = 1.8, hjust = 0.5, size = 5)
# ----- 상단 및 q* 표시 -----
p
# ----- 그래프 -----
p <- ggplot(df_long, aes(x = x, y = pdf, color = case)) +
geom_line(linewidth = 1) +
geom_vline(xintercept = q_star, linewidth = 0.8, color = "black") +  # q*
geom_vline(xintercept = c(mu_L, mu_R), linetype = "dashed", color = "gray50") +
scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
scale_color_manual(values = c("#1B4F72", "#922B21")) +
labs(x = "", y = "확률") +
theme_minimal(base_size = 20) +
theme(
legend.position = "none",
panel.grid.minor = element_blank(),
plot.margin = margin(10, 10, 10, 10)
)
# ----- 상단 및 q* 표시 -----
p
